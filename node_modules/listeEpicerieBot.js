"use strict";

class ListeEpicerieBot
{
  static routeAction(session, text)
    {
      var actionRouted = false;

      switch (session.action)
      {
        case "ADD":
          if (ListeEpicerieBot.add(session, text))
          {
            session.action = null;
            actionRouted = true;
          }
          break;
        case "ADD_CATEGORIES":
          if (ListeEpicerieBot.addCategories(session, text))
          {
            session.action = null;
            actionRouted = true;
          }
          break;
        case "REMOVE_ITEMS":
          if (ListeEpicerieBot.removeItems(session, text))
          {
            session.action = null;
            actionRouted = true;
          }
          break;
        default:
      }

      return actionRouted;
    }

  static add(session, text)
    {
      if (typeof session.storage === "undefined")
      {
        return;
      }

      text = text.replace(/^\/(ajouter).*?\s*/im, "");

      return ListeEpicerieBot.mapTextToItems(session.storage, text, ListeEpicerieBot.addItemToCategory);
    }
  static addCategories(session, text)
    {
      if (typeof session.storage === "undefined")
      {
        return;
      }

      text = text.replace(/^\/(ajouterCategories).*?\s*/im, "");

      return ListeEpicerieBot.mapTextToCategories(session.storage, text, ListeEpicerieBot.addCategory);
    }
  static list(session)
    {
      var list = [];
      for (var category in session.storage)
      {
        list[list.length] = `*${category}*`;
        for (var entry in session.storage[category])
        {
          list[list.length] = `- ${entry} x ${session.storage[category][entry]}`;
        }
      }

      return list.join("\n");
    }
  static removeItems(session, text)
    {
      if (typeof session.storage === "undefined")
      {
        return;
      }

      text = text.replace(/^\/(retirer).*?\s*/im, "");

      return ListeEpicerieBot.mapTextToItems(session.storage, text, ListeEpicerieBot.removeItemFromCategory);
    }

  static addCategory(storage, categoryLabel)
    {
      if (!storage[categoryLabel])
      {
        storage[categoryLabel] = Object.create(null);
      }
    }
  static addItemToCategory(storage, categoryLabel, itemLabel, itemQuantity)
    {
      if (typeof storage[categoryLabel] === "undefined")
      {
        storage[categoryLabel] = Object.create(null);
      }

      storage[categoryLabel][itemLabel] ? storage[categoryLabel][itemLabel] += itemQuantity
                                        : storage[categoryLabel][itemLabel] = itemQuantity;
    }
  static mapTextToCategories(storage, text, action)
    {
      var categories = text.split("\n").filter((entry)=>{return entry.trim();});

      categories.forEach((category) =>
        {
          action(storage, category);
        });

      return categories.length;
    }
  static mapTextToItems(storage, text, action)
    {
      var items = text.split("\n").filter((entry)=>{return entry.trim();});

      items.forEach((item) =>
        {
          var itemDescription = item.split(",").filter((entry)=>{return entry.trim();});
          var itemLabel = null;
          var itemQuantity = 1;
          var categoryLabel = process.env.labelUncategorize;

          var itemLabelIndex = 0;
          var itemQuantityLabel = 1;

          if (itemDescription.length === 3 || (itemDescription.length === 2 && isNaN(itemDescription[1].trim())))
          {
            categoryLabel = itemDescription[0].trim();
            itemLabelIndex = 1;
            itemQuantityLabel = 2;
          }

          itemLabel = itemDescription[itemLabelIndex].trim();

          try
          {
            itemQuantity = Math.round(Number(itemDescription[itemQuantityLabel].trim()));
          }
          catch (exception) {}

          for (var categoryLabelCandidate in storage)
          {
            if (typeof storage[categoryLabelCandidate][itemLabel] !== "undefined")
            {
              categoryLabel = categoryLabelCandidate;
            }
          }

          action(storage, categoryLabel, itemLabel, itemQuantity);
        });

      return items.length;
    }
  static removeItemFromCategory(storage, categoryLabel, itemLabel, itemQuantity)
    {
      if (storage[categoryLabel][itemLabel])
      {
        storage[categoryLabel][itemLabel] -= itemQuantity;
      }
      if (storage[categoryLabel][itemLabel] <= 0)
      {
        delete storage[categoryLabel][itemLabel];
      }
    }
  static removeCategory(storage, categoryLabel)
    {
      if (storage[categoryLabel])
      {
        delete storage[categoryLabel];
      }
    }
}

module.exports = ListeEpicerieBot;
